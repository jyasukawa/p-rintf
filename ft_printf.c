#include "ft_printf.h"

static void	ft_check_format(char c, va_list *ap, int *count, size_t *i)
{
	if (c == 'c')
		ft_putchar_count(va_arg(*ap, int), count);
	else if (c == 's')
		ft_putstr_count(va_arg(*ap, char *), count);
	else if (c == 'p')
		ft_putaddress_count(va_arg(*ap, uintptr_t), count, ON);
	else if (c == 'd' || c == 'i')
		ft_putnbr_count(va_arg(*ap, int), count);
	else if (c == 'u')
		ft_putunsigned_count(va_arg(*ap, unsigned int), count);
	else if (c == 'x' || c == 'X')
		ft_puthex_count(va_arg(*ap, unsigned int), count, c);
	else if (c == '%')
		ft_putchar_count('%', count);
	else
		(*i)--;
}

int	ft_printf(const char *format, ...)
{
	va_list	ap;
	size_t	i;
	int			count;

	i = 0;
	count = 0;
	va_start(ap, format);
	while (format[i])
	{
		if (format[i] == '%')
		{
			i++;
			ft_check_format(format[i], &ap, &count, &i);
			i++;
		}
		else
		{
			ft_putchar_count(format[i], &count);
			i++;
		}
	}
	va_end(ap);
	return (count);
}

// #include <stdio.h>
// int main()
// {
//  char *a = NULL;
// 	printf("[%s]AAA", a);
// 	printf("\n");
// 	ft_printf("[%s]AAA", a);

// 	printf("\n");
// 	printf("\n");

// 	printf("%u", -4);
// 	printf("\n");
// 	ft_printf("%u", -4);

// 	printf("\n");
//   printf("\n");

// 	printf("%c", '\0');
// 	printf("\n");
// 	ft_printf("%c", '\0');

// 	printf("\n");
//   printf("\n");

//   printf("% d", 42);
// 	printf("\n");
// 	ft_printf("% d", 42);
//   printf("\n");
// 	ft_printf("aad", 42);
//   printf("\n");
// 	ft_printf("%ad", 42);

// 	printf("\n");
//   printf("\n");

//   // printf("%  a", 42);
// 	// printf("\n");
// 	// ft_printf("%  a", 42);

// 	printf("\n");
//   printf("\n");

// 	ft_printf("%04.3s%-7.4s", "hello", "world");
// 	printf("\n");
// 	ft_printf("%-021s", NULL);
//   printf("\n");
//   ft_printf(" %%da ", 5);

// 	printf("\n");
// }

// ＜自分が作った関数の挙動説明（本家との違いを説明できるように）＞
// まず、課題で求められている通常の入力に関しては本家と同様に動く
// そのうえで、本家がコンパイルエラーになるようなパターンでもクラッシュせずに一応動くように実装
// %直後のスペースに関してはバッファーマネジメントせずにwrite関数での一文字即だしスタイルのためスペースを出力する実装
// ーー例外処理ーー
// 部分の引数の数が%の数より多い場合ー＞本家はデクリメント方式のため数が一致しないとコンパイル時にエラーが表示される
// ...ft_printfはformat内の%の数(直後が％の場合を除く)分はva_argで引数を取得し、余った引数には手をつけずに終了する
// %sなどで途中文字数がINT_MAXを超えた場合ー＞本家は未定義（環境依存）返り値は文字数、エラーは”負の数”
// レビューでは各自の判断にゆだねられるよう。ただバッファー管理は禁じられているとなると、、、
// ...ft_printfはcountがINT_MAXを超えたらそれ以上は出力せずに-1を返す
// %uで-4などの値が入った場合、本家同様暗黙のキャスト変換出力（動作未定義で可）

// ＜可変長引数...の使い方について＞
// 関数定義の段階では...のデータの大きさがわからない
// ー＞呼び出すときprintf("%d %s", 4 ,c)などの引数からデータ型を判断し、その分の容量をスタックに積む
// ー＞それぞれのデータを取り出して使うには、関数定義でそのデータを格納するデータ型変数を宣言する必要がある
// ー＞int i = 0; char str[];これらの情報も同様に変数という箱に変数名のラベルが貼られてスタックに積まれる
// ー＞マクロで定義されているva_list ap; とすることで、上の行で宣言した変数たちを囲った領域にapというポインタ型の容量を追加したイメージ
// ー＞va_start(ap, format);とすることで、先程のapポインタをformatの直後（...の先頭）にセットする
// ー＞ i = va_arg(ap, int)とすることで、用意した変数にint型でデータを取り出すよう命令する、そしてポインタをデータ型分（今回はint分）進める
// ー＞apポインタが、用意したスタックの領域を超えてアクセスしないよう、va_end(ap)によってapポインタにNULLをセットする
// 本来、formatの部分で、予め...部分の引数の数は与えられ、apポインタはその数が０になるまでデクリメントしながら進んでいくイメージ

// ＜メモ＞
// s == NULLのときの出力(NULL)もwrite関数を使わずputstrを再帰させることで、count++をputcharのみで管理できるようにする
// BUFFER マネジメントはしないという課題要件
// 明示的にキャストしてデータ型揃える
// else ifにしないと最後のデクリメントでｃやｓまで出力されてしまう
// ...選択肢のどれか一つしか実行されないようにする
// %のパターンも明示的に条件分岐に入れる
// 構造体でも普通の変数と同じように扱えるので、個数が固定で関数が終わった後必要のない場合はスタックで確保してあげるといいと思います

// ＜printf関数について＞
// 返り値は、出力した文字数
// * printf は書式文字列 format にしたがい, オブジェクト args を標準出力に書き出す.
// だからfdの指定は１でいい
// それに対し、fprintf は結果を, ファイル記述子 fd の指すファイルに書き出す

// ＜%dと%iの違い＞
// %d と %i は、通常、整数を10進数で出力するためのフォーマット指定子ですが、Cの規格においてはほとんど違いがありません。一般的には以下の点で異なる場合があるかもしれませんが、ほとんどの場合で同じ結果が得られます。
// * プリフィックスの処理: %d はプリフィックスを受け入れませんが、%i はプリフィックスとして 0（8進数）または 0x（16進数）を受け入れることができます。つまり、%i を使用して整数を出力すると、その整数が8進数または16進数の形式である場合、それを解釈しようとします。
// 例:
// int num = 42;
// printf("%i\n", num);    // 42 (10進数)
// printf("%i\n", 052);    // 42 (8進数)
// printf("%i\n", 0x2A);  // 42 (16進数) 
// * 互換性: %d はすべてのC規格に存在し、すべてのCコンパイラでサポートされています。一方、一部の古いCコンパイラは %i をサポートしていないことがあります。
// * 一般的な使用: 一般的には %d が10進数の整数を出力するために使われ、%i は特別なケースで使用されます。例えば、プリフィックスの処理が必要な場合や、プログラムが整数を8進数や16進数として扱う必要がある場合に %i を使用することがあります。
// 基本的には、ほとんどの場合で %d と %i の違いはあまり気にせずに使用できます。ただし、特定の状況で振る舞いが異なることを理解しておくと役立つことがあります 

// ＜write関数のエラー処理について＞
//  INT_MAXを超える文字列を出力する際にオリジナルのprintfは-1を返します
// write()はINT_MAXより大きい数のバイトを渡すとエラーになって-1を返す
// …strlen()みたくわたす場合
// -4 % 7」のように割られる数が負の数の場合の「%」計算の戻り値は処理系により-4か4かが異なる
// writeの戻り値が-1のときのエラー処理をすること。これに関して、libftの課題でwriteの戻り値の処理をしなくてよいのは、libftでwriteの使用が許可されている関数はすべて戻り値がvoid型であるため、writeが-1を返してもそれを外部に伝える手段がないため

// ＜uintptr_t型について＞
// <inttypes.h> によって提供される型として、ポインタを格納するために十分な領域が確保できる符号付きおよび符号なし整数型があります。これらの型には、intptr_t と uintptr_t があります。
// uintptr_t 型をポインタ用の整数型として使用する方が、unsigned long のような基本データ型を使用するよりも便利です。unsigned long は、IPL32 と LP64 データ型モデルの両方でポインタと同じサイズですが、uintptr_t を使用すると、uintptr_t の定義を変更するだけで異なるデータ型モデルを使用できます。このため、他の多くのシステムに移植が可能となります。またこれによって、C プログラムコード中に意図する処理をより明確に記述することができます。
// intptr_t と uintptr_t 型は、アドレス計算をする際にポインタをキャストするのに非常に役に立ちます。long または unsigned long の代わりにこれらを使用することができます。
// intptr_tやuintptr_tというのは、ポインタを格納できるだけの幅のある整数型を定義したもの
// NULL ポインタを数値として正しく解釈するには、C/C++ の規格に従ってキャストを行うことができます。具体的には、uintptr_t という整数型を使用してポインタを数値に変換します。uintptr_t はポインタを整数として表現するのに適した符号なし整数型です。

// ＜va_list＞
// 可変長引数にアクセスするための情報を格納する型です。
// 受け取った複数の引数を一つにまとめる構造体

// ＜va_start＞
// 可変長引数リストを初期化します。
// * 第1パラメータ：引数リスト
// * 第2パラメータ：指定した引数以降を引数リストに格納
// サンプルでは、
// va_start(ap, last);
// last以後の引数をapに格納する。初期化処理だと思って良い。
// 可変長引数（実引数）の情報の取得を開始します。
// 実引数にアクセスする前に呼び出す必要があります。
// va_start()以降に呼び出されるva_arg()、va_endの呼び出しに備えてva_list型のapを初期化します。
// lastは、仮引数の識別子(…)の直前の識別子です。
// lastがregister記憶域クラス、関数型、配列型、引数型変換を行った後の型が元の型と互換性が無い場合は、動作は未定義（環境依存）となります

// ＜va_arg＞
// 引数リストから順番に値を取得します。
// * 第1パラメータ：引数リスト
// * 第2パラメータ：取得時の型
// サンプルでは、
// va_arg( args, type )
// 型を指定しapから順番に引数を取り出す。
// リストからtypeで指定した引数を返します。処理が終了すると、ポインタが加算され、リスト内の次の引数に移動します。(次の引数が返却されるようになります。)
// となっているので、引数リストargsからtype型で値を取得します。
// 可変長引数（実引数）を取得します。
// 2番目の引数(type)と同じ型の返り値を持つように展開されます。
// va_list型のapはva_start()で初期化されたものでなければなりません。
// va_arg()の実行によって、apは順番に引数を返すように変更されます。
// 引数の型typeは、実際の引数の型へのポインタ型であり、特定された型はtypeの前にポインタ(*)を添えることで取得できます。
// va_start()実行後の最初のva_arg()の実行では、va_start()で指定したlastの直後の引数の値を返します。
// 続けて実行すれば、残りの引数の値を順番に返します。

// ＜va_end＞
// 引数リストをクリアします。
// apをクリアする。
// これらを上手く組み合わせることで、可変引数を受け取る関数を作れる。
// * 第1パラメータ：引数リスト
// 引数リストの操作が終わった後、この処理が必要なようです。
// 可変長引数マクロでは引数の個数を判断できないため、関数呼び出し時に引数の数を判断できる情報を第1パラメータで渡すのが定石のようです。
// 前述のサンプルでは、第1パラメータで指定された値をfor文の繰り返し回数に用いて、引数を取得・表示します。
//     for( int i = 0; i < num; ++i ) {
//         printf( "%c\n", va_arg( args, char* ) );
//     }
// 可変長引数（実引数）の取得を終了します。
// va_list apを初期化したva_start()の展開によって参照された可変長引数をもつ関数からの正常な復帰を可能にします。
// va_end()実行後はapが更新され使用できなくなる場合があります。（実装依存）